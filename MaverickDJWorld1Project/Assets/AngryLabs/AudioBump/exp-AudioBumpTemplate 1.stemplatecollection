#T#AngryLabsAudioBumpProperties
// AngryLabs AudioBump
[HideInInspector] m_start_AngryLabsAudioBump ("AudioBump--{reference_property:_AngryLabsAudioBumpEnabled, button_help:{text:Tutorial,action:{type:URL,data:https://www.youtube.com/watch?v=x728WN50JeA&list=PL4_Gy3VRJSmbXfQSldzUiChgABQsoBlLw},hover:YouTube}}", Float) = 0
[HideInInspector][ThryToggle(AngryLabsAudioBumpEnableKeyword)]_AngryLabsAudioBumpEnabled ("Enabled", Float) = 0

[ThryHeaderLabel(Vertex offset control, 21)]
[ToggleUI] _AngryLabsAudioBumpMaskOffsetEnable("Use simple vertex offset", Float) = 0
_AngryLabsAudioBumpOffsetScale("Offset general scale", Float) = 0.01

_AngryLabsAudioBumpOffsetMask("Vertex offset mask--{reference_properties:[_AngryLabsAudioBumpOffsetMaskUV, _AngryLabsAudioBumpOffsetMaskPan]}", 2D) = "black" {}
[HideInInspector][ThryWideEnum(UV0, 0, UV1, 1, UV2, 2, UV3, 3)] _AngryLabsAudioBumpOffsetMaskUV ("UV", Int) = 0
[HideInInspector][Vector2]_AngryLabsAudioBumpOffsetMaskPan("Panning", Vector) = (0, 0, 0, 0)


[ThryWideEnum(Off, 4, Low, 0, LowMid, 1, HighMid, 2, High, 3)] _AngryLabsAudioBumpMaskBandR("Red offset band"   , Int) = 0
_AngryLabsAudioBumpOffsetDirectionR ("Red offset direction", Vector) = (0,0,0,0)

[ThryWideEnum(Off, 4, Low, 0, LowMid, 1, HighMid, 2, High, 3)] _AngryLabsAudioBumpMaskBandG("Green offset band" , Int) = 1
_AngryLabsAudioBumpOffsetDirectionG ("Green offset direction", Vector) = (0,0,0,0)

[ThryWideEnum(Off, 4, Low, 0, LowMid, 1, HighMid, 2, High, 3)] _AngryLabsAudioBumpMaskBandB("Blue offset band"  , Int) = 2
_AngryLabsAudioBumpOffsetDirectionB ("Blue offset direction", Vector) = (0,0,0,0)

[ThryWideEnum(Off, 4, Low, 0, LowMid, 1, HighMid, 2, High, 3)] _AngryLabsAudioBumpMaskBandA("Alpha offset band" , Int) = 3
_AngryLabsAudioBumpOffsetDirectionA ("Alpha offset direction", Vector) = (0,0,0,0)

[ThryHeaderLabel(Blend Shape control, 21)]
[ThryHeaderLabel( Use the tool located in the unity menu at Tools AngryLabs Bake Blend Shape To Texture to generate the texture, 13)]
[ToggleUI] _AngryLabsAudioBumpUseBlendshapes("Use Blendshape texture", Float) = 0
_AngryLabsAudioBumpScale ("Blendshape Scale Correction", Float) = 1.0
_AngryLabsAudioBumpBlendshapes("Blend shape texture", 2D) = "black" { }

[ThryHeaderLabel(Audiolink Bands for blend shapes, 13)]
[ThryHeaderLabel(x is Low y, 13)]
[ThryHeaderLabel(y is MidLow, 13)]
[ThryHeaderLabel(z is MidHigh w is High, 13)]
[ThryHeaderLabel(z is MidHigh, 13)]
[ThryHeaderLabel(w is High, 13)]
_AngryLabsAudioBumpBlend1 ("Blendshape 1", Vector) = (1.0, 0.0, 0.0, 0.0)
_AngryLabsAudioBumpBlend2 ("Blendshape 2", Vector) = (0.0, 1.0, 0.0, 0.0)
_AngryLabsAudioBumpBlend3 ("Blendshape 3", Vector) = (0.0, 0.0, 1.0, 0.0)
_AngryLabsAudioBumpBlend4 ("Blendshape 4", Vector) = (0.0, 0.0, 0.0, 1.0)

[HideInInspector] m_end_AngryLabsAudioBump ("AudioBump - end", Float) = 0

#T#AngryLabsAudioBumpKeywords
// AngryLabs AudioBump
#pragma shader_feature AngryLabsAudioBumpEnableKeyword

#T#AngryLabsAudioBumpVariables
// AngryLabs AudioBump
#if AngryLabsAudioBumpEnableKeyword
	float _AngryLabsAudioBumpMaskOffsetEnable;
	sampler2D _AngryLabsAudioBumpOffsetMask;
	float4 _AngryLabsAudioBumpOffsetMask_ST;
	float4 _AngryLabsAudioBumpOffsetMaskPan;
	int _AngryLabsAudioBumpOffsetMaskUV;
	float _AngryLabsAudioBumpOffsetScale;

	float4 _AngryLabsAudioBumpOffsetDirectionR;
	float4 _AngryLabsAudioBumpOffsetDirectionG;
	float4 _AngryLabsAudioBumpOffsetDirectionB;
	float4 _AngryLabsAudioBumpOffsetDirectionA;
	int _AngryLabsAudioBumpMaskBandR;
	int _AngryLabsAudioBumpMaskBandG;
	int _AngryLabsAudioBumpMaskBandB;
	int _AngryLabsAudioBumpMaskBandA;

	int _AngryLabsAudioBumpUseBlendshapes;
	sampler2D_float _AngryLabsAudioBumpBlendshapes;
	float4 _AngryLabsAudioBumpBlendshapes_TexelSize;
	
	float _AngryLabsAudioBumpScale;
	float4 _AngryLabsAudioBumpBlend1;
	float4 _AngryLabsAudioBumpBlend2;
	float4 _AngryLabsAudioBumpBlend3;
	float4 _AngryLabsAudioBumpBlend4;
#endif


#T#AngryLabsAudioBumpFunctions
// AngryLabs AudioBump
#if AngryLabsAudioBumpEnableKeyword

float2 AngryLabsAudioBumpIndexToUV(uint index, uint textureSize){
	int x = index % textureSize;
	int y = index / textureSize;
	
	float2 raw = float2(x + 0.5, y + 0.5) / textureSize;
	
	return raw;
}

float3 AngryLabsAudioBumpVertexDisplace (sampler2D_float blendTexture, int index, float amount, float3 position, inout float3 normal, float3 tangent, float3 binormal, int textureSize, float blendScale) {
	float2 one = float2(1.0 / textureSize, 0);
		
	float2 blendSampleUV;
	float3 sampledDelta;
	float3 delta;
	
	blendSampleUV = AngryLabsAudioBumpIndexToUV(index, textureSize);
	sampledDelta = tex2Dlod( blendTexture, float4( blendSampleUV, 0, 0.0) ).rgb;
	delta = sampledDelta;
	delta *= amount * blendScale;
	position += ( delta.x * normal ) + ( delta.y * tangent ) + ( delta.z * binormal );
	
	blendSampleUV = AngryLabsAudioBumpIndexToUV(index + 1, textureSize);
	sampledDelta = tex2Dlod( blendTexture, float4( blendSampleUV, 0, 0.0) ).rgb;
	delta = sampledDelta * blendScale;
	delta *= amount;
	normal += ( delta.x * normal ) + ( delta.y * tangent ) + ( delta.z * binormal );
	normal = normalize(normal);
	
	return position;
}

float AngryLabsAudioBumpVertexBandSelect(int band, float4 audio){
	switch(band){
		case 0: return audio.x; 
		case 1: return audio.y; 
		case 2: return audio.z; 
		case 3: return audio.w; 
		default: return 0.0f;
	}
}

float3 AngryLabsAudioBumpApplyVertexOffset(float4 audio, float4 maskValue, float generalScale, float3 normal, 
		float4 directionR, float4 directionG, float4 directionB, float4 directionA,
		int bandR, int bandG, int bandB, int bandA
		) {
	float4 rd = AngryLabsAudioBumpVertexBandSelect(bandR, audio) * directionR * maskValue.r;
	float4 gd = AngryLabsAudioBumpVertexBandSelect(bandG, audio) * directionB * maskValue.g;
	float4 bd = AngryLabsAudioBumpVertexBandSelect(bandB, audio) * directionG * maskValue.b;
	float4 ad = AngryLabsAudioBumpVertexBandSelect(bandA, audio) * directionA * maskValue.a;
	
	float4 total = rd + gd + bd + ad;
	
	float3 ret = total.xyz + total.w * normal;
	return ret * generalScale * audio;
}

float3 AngryLabsAudioBumpApplyBlendshape(float4 audio, int vertex_id, float textureSize, sampler2D blendShapes, float4 blend1, float4 blend2, float4 blend3, float4 blend4, appdata v, float blendScale) {
	float4 audioMod[4] = { blend1, blend2, blend3, blend4 };
	
	float2 vcolor_uv = float2(0.5, 0.5) / textureSize;
	float4 vcolor = tex2Dlod( blendShapes , float4( vcolor_uv, 0, 0.0) ).rgba;
	int verticies = vcolor.r;
	int shapes = vcolor.g;
	
	float3 ret = float3(0,0,0);
	
	float3 biNormal = normalize(cross( v.normal , v.tangent.xyz )) * v.tangent.w;
	float3 normal = v.normal;
	float3 tangent = v.tangent;
	
	// Sum up the blend shape offsets into "ret"
	for(int i=0; i<shapes; i++) 
	{
		float4 audioMuled = audio * audioMod[i];
		float audioLen = length(audioMuled);
		
		int vert = 1 + vertex_id * 2 + verticies * i * 2;
		ret += AngryLabsAudioBumpVertexDisplace(blendShapes, vert, audioLen, ret, normal, tangent, biNormal, textureSize, blendScale);
	}
	return ret;
}

#endif


#T#AngryLabsAudioBumpImplimentation
// AngryLabs AudioBump
#ifdef AngryLabsAudioBumpEnableKeyword
	do {

		//just inline the check instead of pulling in the whole audio link 
		int hasAudioLink;
		#if !defined(AUDIOLINK_STANDARD_INDEXING)
		int width, height;
		_AudioTexture.GetDimensions(width, height);
		hasAudioLink =  width > 16;
		#else
		hasAudioLink = _AudioTexture_TexelSize.z > 16;
		#endif
		
		if(!hasAudioLink) break;

		float4 audio = float4(
								AudioLinkData(ALPASS_AUDIOBASS).r,
								AudioLinkData(ALPASS_AUDIOLOWMIDS).r,
								AudioLinkData(ALPASS_AUDIOHIGHMIDS).r,
								AudioLinkData(ALPASS_AUDIOTREBLE).r
								);
					
		float3 angryLabsAudioBumpOffset = float3(0, 0, 0);
		
		float4 zero = float4(0,0,0,0);
		
		float3 oNormal = o.objNormal;
		
		float2 uv = zero.xy;
		switch(_AngryLabsAudioBumpOffsetMaskUV){
			case 0: uv = o.uv[0]; break;
			case 1: uv = o.uv[1]; break;
			case 2: uv = o.uv[2]; break;
			case 3: uv = o.uv[3]; break;
		}
		
		uv += _Time.y * _AngryLabsAudioBumpOffsetMaskPan;
		
		float4 maskValue = tex2Dlod(_AngryLabsAudioBumpOffsetMask,  float4(TRANSFORM_TEX(uv, _AngryLabsAudioBumpOffsetMask) , 0, 0)).rgba;
		
		if(_AngryLabsAudioBumpMaskOffsetEnable){
			angryLabsAudioBumpOffset += AngryLabsAudioBumpApplyVertexOffset(
				audio,
				maskValue,
				_AngryLabsAudioBumpOffsetScale,
				oNormal,
				_AngryLabsAudioBumpOffsetDirectionR,
				_AngryLabsAudioBumpOffsetDirectionG,
				_AngryLabsAudioBumpOffsetDirectionB,
				_AngryLabsAudioBumpOffsetDirectionA,
				_AngryLabsAudioBumpMaskBandR,
				_AngryLabsAudioBumpMaskBandG,
				_AngryLabsAudioBumpMaskBandB,
				_AngryLabsAudioBumpMaskBandA
			);
		}
		
		if(_AngryLabsAudioBumpUseBlendshapes) {
			angryLabsAudioBumpOffset += AngryLabsAudioBumpApplyBlendshape(
				audio,
				v.vertexId,
				_AngryLabsAudioBumpBlendshapes_TexelSize.z,
				_AngryLabsAudioBumpBlendshapes,
				_AngryLabsAudioBumpBlend1, _AngryLabsAudioBumpBlend2, _AngryLabsAudioBumpBlend3, _AngryLabsAudioBumpBlend4,
				v,
				_AngryLabsAudioBumpScale
				);
		}
		
		localOffset += angryLabsAudioBumpOffset;
		worldOffset += angryLabsAudioBumpOffset;
	} while(false);
	
#endif
